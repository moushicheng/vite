依赖图的构件时机还是发生在 createServer 中，
下面我们就来看看它是如何构建的吧

## 依赖图构建

```javascript
const moduleGraph = new ModuleGraph((url, ssr) =>
  container.resolveId(url, undefined, { ssr })
)
const container = await createPluginContainer(config, moduleGraph, watcher)
```

对于依赖图
你会发现 constructor 似乎没有做什么工作，这是因为 vite 的模块机制是按需加载的，它不会一开始就分析整个项目的模块结构，这与 webpack 完全不同。

```javascript
export class ModuleGraph {
  urlToModuleMap = new Map<string, ModuleNode>()
  idToModuleMap = new Map<string, ModuleNode>()
  // a single file may corresponds to multiple modules with different queries
  fileToModulesMap = new Map<string, Set<ModuleNode>>()
  safeModulesPath = new Set<string>()

  constructor(
    private resolveId: (
      url: string,
      ssr: boolean
    ) => Promise<PartialResolvedId | null>
  ) {}

  async getModuleByUrl(){
    //...
  }
  //下面都是些方法，暂时隐去
  getModuleById
  getModulesByFile
  onFileChange
  invalidateModule
  invalidateAll
  /**
   * Update the module graph based on a module's updated imports information
   * If there are dependencies that no longer have any importers, they are
   * returned as a Set.
   */
  async updateModuleInfo
  async ensureEntryFromUrl
  // some deps, like a css file referenced via @import, don't have its own
  // url because they are inlined into the main css import. But they still
  // need to be represented in the module graph so that they can trigger
  // hmr in the importing css file.
  createFileOnlyEntry
  // for incoming urls, it is important to:
  // 1. remove the HMR timestamp query (?t=xxxx)
  // 2. resolve its extension so that urls with or without extension all map to
  // the same module
  async resolveUrl
}

```

## 插件容器

先浅看一下 container 的结构

```javascript
  const container: PluginContainer = {
    options: await (async () => {
     //...
    })(),

    getModuleInfo,

    async buildStart() {
    //...
    },

    async resolveId(rawId, importer = join(root, 'index.html'), options) {
      //...
    },

    async load(id, options) {
     //...
    }
    async transform(code, id, options) {
      //...
    },

    async close() {
     //...
    }
  }

```

container 其实是集合了一堆钩子处理函数的对象

### options

options 属性其实就是包含了 acorn,acornInjectPlugins，以及被所有 optionsHook 钩子处理后的 options(`rollupOptions` )对象。
还有一点这个 options 是 rollup 提供的 options，跟 worker.rollupOptions 有关，所以这里的 options 是不会包含大多数 vite.config.ts 的配置项的
详见[worker](https://cn.vitejs.dev/config/worker-options.html)

总结一下，options 处理的是 rollupOptions，而不是完整的 vite config。

```javascript
 options: await (async () => {
      let options = rollupOptions
      //执行所有options钩子
      for (const optionsHook of getSortedPluginHooks('options')) {
        options = (await optionsHook.call(minimalContext, options)) || options
      }
      //如果options包含要注入acorn的插件，就执行
      if (options.acornInjectPlugins) {
        parser = acorn.Parser.extend(
          ...(arraify(options.acornInjectPlugins) as any)
        )
      }
      return {
        acorn,
        acornInjectPlugins: [],
        ...options
      }
    })(),
```

看完之后可能会有一个疑问：

> acorn 是什么?
> 详见[acorn github](https://github.com/acornjs/acorn)或者看看[翻译](https://juejin.cn/post/6850418116762173448)
> A tiny, fast JavaScript parser, written completely in JavaScript.
> 大概是一个 JavaScript 解析器吧，它通过插件来定义解析器行为，而插件其实是个函数, 包含了一个从 Parser 继承下来的类, 使用插件非常简单, 可以通过 Parser.extend 方法来集成你需要的插件, 不过比较尴尬的是, 如果你要使用多个插件, Parser.extend 会被反复调用, 建议最好是把相关插件合并到一起, 以避免对 JavaScript 引擎优化器不必要的干扰

### getModuleInfo

id 就是用户写在源码里的'../mod.js'
逻辑很简单，查找模块，处理 module.info，返回 info

```javascript
  function getModuleInfo(id: string) {
    //getModuleById=>return this.idToModuleMap.get(removeTimestampQuery(id)) removeTimestampQuery不知道干嘛用的，当直接返回id吧！
    const module = moduleGraph?.getModuleById(id)
    if (!module) {
      return null
    }
    if (!module.info) {
      module.info = new Proxy(
        { id, meta: module.meta || EMPTY_OBJECT } as ModuleInfo,
        ModuleInfoProxy
      )
    }
    return module.info
  }
```

### buildStart

```javascript
async buildStart() {
      await hookParallel(
        'buildStart',
        (plugin) => new Context(plugin),
        () => [container.options as NormalizedInputOptions]
      )
    }
```

核心逻辑,
这里的处理很聪明和 rollup 的官方文档对[sequential](https://rollupjs.org/guide/en/#build-hooks)类型插件的描述一致：
即，在[A B C D E F] 的插件里 含有 sequential 的 D 插件，会将执行顺序变成
[A B C] D [E F]
其中[A B C]若是同步钩子，则还是按顺序
若是异步钩子，则会被 Promise.all 同步执行。

```javascript
async function hookParallel<H extends AsyncPluginHooks & ParallelPluginHooks>(
    hookName: H,
    context: (plugin: Plugin) => ThisType<FunctionPluginHooks[H]>,
    args: (plugin: Plugin) => Parameters<FunctionPluginHooks[H]>
  ): Promise<void> {
    const parallelPromises: Promise<unknown>[] = []
    for (const plugin of getSortedPlugins(hookName)) {
      const hook = plugin[hookName]
      if (!hook) continue
      const handler: Function = 'handler' in hook ? hook.handler : hook
      if ((hook as { sequential?: boolean }).sequential) {
        await Promise.all(parallelPromises)
        parallelPromises.length = 0
        await handler.apply(context(plugin), args(plugin))
      } else {
        parallelPromises.push(handler.apply(context(plugin), args(plugin)))
      }
    }
    await Promise.all(parallelPromises)
  }
```

钩子执行时，我们会发现有两个对象，this (context)和 args
对于 buildStart 来说，
this 是当前异步钩子的新上下文，这是为了以一种并发安全的方式运行正被激活的插件。
args 就是前面 options 钩子处理完之后的 options

### resolveId

这个钩子的执行逻辑看着长，实际上理解成本并不高，看看笔者在其中的注释就好了
resolveId 是 hookFirst async 型钩子，如果按序执行钩子时发现任一个返回值为非 null，则退出程序
（有一种递交的感觉，A 处理不了就返回 null 交给 B，B 处理不了就交给 C，C 能处理则返回一个数据）

```typescript

  async resolveId(rawId, importer = join(root, 'index.html'), options) {
      const skip = options?.skip
      const ssr = options?.ssr
      const scan = !!options?.scan
      const ctx = new Context()
      ctx.ssr = !!ssr
      ctx._scan = scan
      ctx._resolveSkips = skip

      let id: string | null = null
      const partial: Partial<PartialResolvedId> = {}
      //按序执行resolveId钩子
      for (const plugin of getSortedPlugins('resolveId')) {
        if (!plugin.resolveId) continue
        if (skip?.has(plugin)) continue

        ctx._activePlugin = plugin

        //取用钩子执行逻辑
        const handler =
          'handler' in plugin.resolveId
            ? plugin.resolveId.handler
            : plugin.resolveId
        //执行钩子，其中rawId就是源码中的比如：'../index.js'，而importer就是完整路径'D:/yourProject/index.js'，
        //剩下的options具体作用见rollup文档
        //https://rollupjs.org/guide/en/#resolveid
        const result = await handler.call(ctx as any, rawId, importer, {
          custom: options?.custom,
          isEntry: !!options?.isEntry,
          ssr,
          scan
        })
        //result为null则递交下一个钩子继续做处理
        if (!result) continue

        if (typeof result === 'string') {
          id = result
        } else {
          id = result.id
          Object.assign(partial, result)
        }
        // resolveId() is hookFirst - first non-null result is returned.
        break
      }
      if (id) {
        partial.id = isExternalUrl(id) ? id : normalizePath(id)
        return partial as PartialResolvedId
      } else {
        return null
      }
    },
```

其实很简单，就是有一个 hookFist 的执行逻辑，
钩子按顺序执行，若返回 null，则交给下一个 resolveId 钩子处理 id，直到 id 被正确的处理（即返回正确处理好后的 id）就 break;
如果你对[rollup](https://rollupjs.org/guide/en/#resolveid)的插件开发熟悉就会发现这些共享钩子就是 rollup 的插件钩子，且执行逻辑和 rollup 文档内部描述的一致。

### load

类型：async, firshook
load 同样是个 firsthook 类型的钩子和 resolveId 运行逻辑基本一致，但其会取返回结果来更新模块信息
load 处理的是当前 id 对应的模块
其最终返回的是 string | null |{code,ast,map}对象

```javascript
    async load(id, options) {
      const ssr = options?.ssr
      const ctx = new Context()
      ctx.ssr = !!ssr
      for (const plugin of getSortedPlugins('load')) {
        if (!plugin.load) continue
        ctx._activePlugin = plugin
        const handler =
          'handler' in plugin.load ? plugin.load.handler : plugin.load
        const result = await handler.call(ctx as any, id, { ssr })
        //更新模块信息并退出函数
        if (result != null) {
          if (isObject(result)) {
            updateModuleInfo(id, result)
          }
          return result
        }
      }
      return null
    },
  function updateModuleInfo(id: string, { meta }: { meta?: object | null }) {
    if (meta) {
      const moduleInfo = getModuleInfo(id)
      if (moduleInfo) {
        moduleInfo.meta = { ...moduleInfo.meta, ...meta }
      }
    }
  }
```

最后的 transform 就不说了跟前面差不多
